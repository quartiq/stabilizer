searchState.loadedDescShard("miniconf", 0, "miniconf: serialize/deserialize/access reflection for trees\nA node does not exist at runtime.\nA node could not be accessed or is invalid.\nNumber of bits in the representation including the marker …\nThe total number of bits this representation can store.\nConcatenate two <code>Keys</code> of different types\nErrors that can occur while visting nodes with …\nThe empty value\nThe possible error when transcoding.\nCounting wrapper for iterators with known exact size\nThere was an error during finalization.\nA representative schema item for a homogeneous array\nHomogeneous numbered children\nIndices of <code>usize</code> to identify a node in a <code>TreeSchema</code>\nThe visitor callback returned an error.\nThe value provided could not be serialized or deserialized …\nAn internal node with children\nBe converted into a <code>Keys</code>\nThe specific <code>Keys</code> implementor.\nJSON style path notation\nJSON style path notation iterator\nConvert a key into a node index given an internal node …\nThe key is invalid.\nTree traversal error\nErrors that can occur when using the Tree traits.\nCapability to yield and look up <code>Key</code>s\n<code>Keys</code>/<code>IntoKeys</code> for Iterators of <code>Key</code>\nA leaf without metadata\n<code>Serialize</code>/<code>Deserialize</code>/<code>Any</code> leaf\nThe metadata type\nA named schema item\nNamed children\nNode iterator\nThe key was not found (index parse failure or too large, …\nA numbered schema item\nNumbered heterogeneous children\nA bit-packed representation of multiple indices.\nPath with named keys separated by a separator char\nString split/skip wrapper, smaller/simpler than …\nSchema for this tree level\nType of a node: leaf or internal\nCompound errors\nMetadata about a <code>TreeSchema</code> namespace.\nTrack leaf node encounter\nThe key is too long and goes beyond a leaf node.\nThe key ends early and does not reach a leaf node.\nTrack key depth\nLook up an <code>IntoKeys</code> in a <code>Schema</code> and transcode it.\nDerive the <code>TreeSchema</code>, <code>TreeSerialize</code>, <code>TreeDeserialize</code>, and …\nAccess any node by keys.\nDerive the <code>TreeAny</code> trait for a struct or enum.\nDeserialize a leaf node by its keys.\nDerive the <code>TreeDeserialize</code> trait for a struct or enum.\nShorthand for owned deserialization through <code>TreeDeserialize</code>…\nTraversal, iteration of keys in a tree.\nDerive the <code>TreeSchema</code> trait for a struct or enum.\nSerialize a leaf node by its keys.\nDerive the <code>TreeSerialize</code> trait for a struct or enum.\nThe value could not be accessed.\nErrors that can occur while accessing a value.\nReturn the number of bits required to represent <code>num</code>.\nChain another <code>Keys</code> to this one.\nChain another <code>Keys</code> to this one.\nThe exact total number of leaf nodes.\nDeny access tools.\nWhether a leaf node as been encountered\nTraverse from the root to a leaf and call a function for …\nDeserialize a leaf node by its keys.\nWrap the iterator in an exact size counting iterator that …\nFinalize the keys, ensure there are no more.\nConvert the key <code>self</code> to a <code>usize</code> index\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBuild a <code>Packed</code> from a LSB-aligned representation with the …\nGet the schema of the node identified by keys.\nThe primitive value\nPerform a name-to-index lookup\nReturn the outer metadata for the given child\nLook up outer and inner metadata given keys.\nPerform a index-to-name lookup\nReturn the child schema at the given index\nCreate a new internal node schema with homogenous children …\nBorrow the inner <code>Keys</code>\nBorrow the inner <code>Keys</code>\nInternal schemata\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSplit into inner <code>Keys</code> and leaf node flag\nSplit into inner <code>Keys</code> and leaf node flag\nExtract the inner value\nSplit indices into data and length\nExtract just the path\nConvert <code>self</code> into a <code>Keys</code> implementor.\nReturn the representation aligned to the LSB with the …\nSee <code>Self::is_leaf()</code>\nThe value is empty.\nSee <code>Self::len()</code>\nWhether this node is a leaf\n<code>TreeSerialize</code>/<code>TreeDeserialize</code> with “JSON and <code>/</code>”.\nLeaf implementation using serde::{Serialize, Deserialize}\nWhether a leaf node as been encountered\nReturn the number of direct child nodes\nNumber of child nodes\nNumber of bits stored.\nThe length of the indices keys\nThe number of items\nThe maximum number of bits (see <code>crate::Packed</code>)\nThe maximum node depth.\nAdd separator length to the maximum path length.\nThe maximum length of a path in bytes.\nThe outer metadata\nThe outer metadata\nThe outer metadata\nInner metadata\nObtain a mutable reference to a <code>dyn Any</code> trait object for a …\nObtain a mutable reference to a leaf of known type by key.\nObtain a mutable reference to a leaf of known type by key.\nThe name of the item\nCreate a new internal node schema with numbered children …\nCreate a new <code>Short</code>\nCreate a new <code>Track</code>\nCreate a new Numbered schema item with no outer metadata.\nCreate a new Named schema item with no outer metadata.\nCreate a new Homogeneous schema item with no outer …\nRecursively compute Shape for a Schema.\nCreate a new <code>Packed</code> from a <code>usize</code>.\nInterpret a str as a JSON path to be iterated over.\nCreate a new iterator with default root and initial state.\nCreate a new <code>Indices</code>\nCreate a new <code>PathIter</code>\nCreate a new <code>Packed</code> from LSB aligned <code>usize</code>\nLook up the next key in a <code>Internal</code> and convert to <code>usize</code> …\nLook up the next item from keys and return a child index\nReturn an iterator over nodes of a given type\nCreate a new internal node schema with named children and …\nPassthrough Tree*\nRemove the given number of MSBs and return them.\n<code>TreeSerialize</code>/<code>TreeDeserialize</code> with <code>postcard</code>.\nBlind deserialize a leaf node by its keys.\nPush the given number <code>bits</code> of <code>value</code> as new LSBs.\nObtain a reference to a <code>dyn Any</code> trait object for a leaf …\nObtain a reference to a leaf of known type by key.\nObtain a reference to a leaf of known type by key.\nReturn the root depth\nCreate a new <code>PathIter</code> starting at the root.\nReturn the underlying schema\nThe child schema\nThe child schema\nThe schema of the child nodes\nThe path hierarchy separator\nSerialize a node by keys.\nThe Shape of the schema\nTrack whether a leaf node is reached\nTrack whether a leaf node is reached\nReturn the current state\n<code>TryFrom&lt;&amp;str&gt;</code>/<code>AsRef&lt;str&gt;</code> leaf\nTrack depth\nTrack depth\nPerform a node lookup of a <code>K: IntoKeys</code> on a <code>Schema</code> and …\nTranscode keys to a new keys type representation\nCreate a new iterator.\nLimit and start iteration to at and below the provided …\n<code>TreeSchema::SCHEMA</code>\n<code>TreeDeserialize::deserialize_by_key()</code>\n<code>TreeAny::mut_any_by_key()</code>\n<code>TreeDeserialize::probe_by_key()</code>\n<code>TreeAny::ref_any_by_key()</code>\n<code>TreeSerialize::serialize_by_key()</code>\nRetrieve a serialized value by path.\nRetrieve a serialized value by key.\nUpdate a node by path.\nUpdate a node by key.\n<code>TreeSchema::SCHEMA</code>\n<code>TreeDeserialize::deserialize_by_key()</code>\n<code>TreeAny::mut_any_by_key()</code>\n<code>TreeDeserialize::probe_by_key()</code>\n<code>TreeAny::ref_any_by_key()</code>\n<code>TreeSerialize::serialize_by_key()</code>\n<code>TreeDeserialize::deserialize_by_key()</code>\n<code>TreeAny::mut_any_by_key()</code>\n<code>TreeDeserialize::probe_by_key()</code>\n<code>TreeAny::ref_any_by_key()</code>\n<code>TreeSerialize::serialize_by_key()</code>\nGet and serialize a node value into a <code>postcard</code> flavor.\nDeserialize and set a node value from a <code>postcard</code> flavor.\n<code>TreeSchema::SCHEMA</code>\n<code>TreeDeserialize::deserialize_by_key()</code>\n<code>TreeAny::mut_any_by_key()</code>\n<code>TreeDeserialize::probe_by_key()</code>\n<code>TreeAny::ref_any_by_key()</code>\n<code>TreeSerialize::serialize_by_key()</code>")