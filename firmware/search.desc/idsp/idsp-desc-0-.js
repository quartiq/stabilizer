searchState.loadedDescShard("idsp", 0, "Embedded DSP algorithms\nAccumulator type\nWrapping Accumulator\nAccumulating oscillator\nGain of cordic in circular mode.\nGain of cordic in hyperbolic mode.\nCombine two different filters in cascade\nCascaded integrator comb structure\nHelper trait unifying fixed point and floating point …\nA complex number in Cartesian form.\nComplex extension trait offering DSP (fast, good accuracy) …\nFilter configuration type.\nDelta-sigma modulator\nSingle inpout single output i32 filter\nA constant <code>Complex</code> <em>i</em>, the imaginary unit.\nLockin filter\nArbitrary order, high dynamic range, wide coefficient …\nFirst order lowpass\nSecond order lowpass\nHighest value\nLowest value\nFull scale fixed point multiplication.\nNegative multiplicative identity, equal to <code>-Self::ONE</code>.\nNyquist zero\nMultiplicative identity\nA constant <code>Complex</code> 1.\nType-II, sampled phase, discrete time PLL\nReciprocal PLL.\nRepeat another filter\nStart out of bounds\nStop out of bounds\nExponential sweep\nSweep parameter error\nOverflow unwrapper.\nAdditive identity\nA constant <code>Complex</code> 0.\nSquare of magnitude\nReturn the absolute square (the squared magnitude).\nAngle\nReturn the angle.\n2-argument arctangent function.\nZero-initialize the filter state\nClamp to between min and max\nComb delay\nReturns the complex conjugate. i.e. <code>re - i im</code>\nEvaluate integrated sweep at a given time\nReturns …\nReturns …\nCompute the cosine and sine of an angle. This is ported …\nNumber of cycles per harmonic\nSamples per decade\nIngest a new high-rate sample and optionally retrieve next …\nHarmonic delay/length\nReturns <code>x, z + y/x</code>\nDivision (scaled)\nCreate new sweep\nReturn the current frequency estimate\nReturn the current frequency estimate\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUnit magnitude from angle\nReturn a Complex on the unit circle given an angle.\nParses <code>a +/- bi</code>; <code>ai +/- b</code>; <code>a</code>; or <code>bi</code> where <code>a</code> and <code>b</code> are of …\nParses <code>a +/- bi</code>; <code>ai +/- b</code>; <code>a</code>; or <code>bi</code> where <code>a</code> and <code>b</code> are of …\nFilter gain\nRight shift amount\nReturn the current filter output\nCurrent decimator output\nCurrent interpolator output\nHalf-band filters and cascades\nReturns the imaginary unit.\nIIR filters, coefficients and applications\nImaginary portion of the complex number\nOptionally ingest a new low-rate sample and retrieve the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>1/self</code>\nInverse filter\nChecks if the given complex number is finite\nChecks if the given complex number is infinite\nChecks if the given complex number is NaN\nChecks if the given complex number is normal\nReturns the L1 norm <code>|re| + |im|</code> – the Manhattan distance …\nLog2 approximation\nlog2(power) re full scale approximation\nProper scaling and potentially using a wide accumulator. …\nReturns <code>x, y + x*z</code>\nScaled multiplication for fixed point\nMultiplication (scaled)\nCreate a new <code>Complex</code>\nCreate a new accumulator with given initial state and step.\nCreate a new RPLL instance.\nCreate a new exponential sweep\nCreate a new accumulating oscillator\nCreate a new zero-initialized filter with the given rate …\nReturns the square of the norm (since <code>T</code> doesn’t …\nSamples per octave\nFilter order\nSubtract <code>y - x</code> with signed overflow.\nReturn the current phase estimate\nReturn the current phase estimate\nThe current phase\nRaises <code>self</code> to a signed integer power.\nRaises <code>self</code> to an unsigned integer power.\nScale and quantize a floating point value.\nContinuous time exponential sweep rate\nRate change\nRate of exponential increase\nReal portion of the complex number\nImpulse response length\nStaturating addition\nCombine high and low i32 into a single downscaled i32, …\nSaturating subtraction\nMultiplies <code>self</code> by the scalar <code>t</code>.\nUpdate the filter so that it outputs the provided value. …\nSet the rate change\nEstablish a settled filter state\nEstablish a settled filter state\nReturns <code>F*sqrt(x**2 + y**2), z + atan2(y, x)/PI</code>\nReturns <code>G*sqrt(x**2 - y**2), z + atanh2(y, x)</code>\nCurrent continuous time state\nCurrent state\nCurrent phase\nState variable filter\nAccepts/provides new slow-rate sample\nDivides <code>self</code> by the scalar <code>t</code>.\nUpdate the filter with a new sample.\nUpdate the lockin with a sample taken at a given phase.\nUpdate the PLL with a new phase sample. This needs to be …\nAdvance the RPLL and optionally supply a new timestamp.\nFeed a new sample..\nIngest input sample, emit new output.\nUpdate the lockin with a sample taken at a local …\nThe current number of wraps\nCurrent output including wraps\nFilter input items into output items.\nMax low-rate block size (HbfIntCascade input, …\nPassband width in units of lowest sample rate\n140 dB stopband, 2 µdB passband ripple, limited by f32 …\nStandard/optimal half-band filter cascade taps\nHalf band decimator (decimate by two)\nHalf-band decimation filter cascade with optimal taps\nHalf band interpolator (interpolation rate 2)\nHalf-band interpolation filter cascade with optimal taps.\nInput/output item type.\nSymmetric FIR filter prototype.\nReturn the block size granularity and the maximum block …\nObtain a mutable reference to the input items buffer space.\nObtain a mutable reference to the input items buffer space\nCascade depth\nCascade depth\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerform the FIR convolution and yield results iteratively.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMove items as new filter state.\nCreate a new <code>SymFir</code>.\nCreate a new <code>HbfDec</code>.\nNon-zero (odd) taps from oldest to one-before-center. …\nProcess a block of items.\nFinite impulse response length in numer of output items …\nSet cascade depth\nSet cascade depth\nPID action\nAn allpass\nFloating point BA coefficients before quantization\nNormalized SI unit coefficients\nNormalized SI unit coefficients\nA bandpass\nRelative bandwidth in octaves\nBiquad IIR filter\nRepresentation of Biquad\nDerivative=, 20 dB per decade\nDouble derivative, 40 dB per decade\nStandard audio biquad filter builder\nStandard biquad filters: Notch, Lowpass, Highpass, Shelf …\nStandard biquad filters: Notch, Lowpass, Highpass, Shelf …\nStandard biquad parametrizations\nNamed gains\nA “hold” filter that ingests input and maintains output\nA highpass\nA high shelf\nIntegrator\nIntegrating, -20 dB per decade\nDouble integrator\nDouble integrating, -40 dB per decade\nA unity gain filter\nIntegrator over harmonic oscillator\nA lowpass\nA low shelf\nA notch\nFeedback term order\nProportional\nProportional\nA peaking filter\nPID Controller parameters\nA PID\nA PID\nPID controller builder\nQ, 1/sqrt(2) for critical\nRaw, unscaled, possibly fixed point machine unit …\nRaw, unscaled, possibly fixed point machine unit …\nTransition/corner shape\nSlope steepnes, 1 for critical\nFilter type\nAn allpass filter\nSet relative critical angular frequency\nFilter coefficients\nCoefficient array: [[b0, b1, b2], [a0, a1, a2]]\nMutable reference to the filter coefficients.\nBand pass\nSet the relative bandwidth\nCompute coefficients and return <code>Biquad</code>.\nReturn the <code>Biquad</code>\nBuild a biquad\nSet relative critical frequency\nCompute the overall (DC/proportional feed-forward) gain.\nSet crititcal frequency from absolute units.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to create Self from the raw representation\nSet reference gain\nGain for a given action\nGain\nSet reference gain in dB\nHigh pass filter\nLow shelf\nI/HO\nCompute input-referred (<code>x</code>) offset.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet inverse Q parameter of the filter\nGain limit for a given action\nGain imit\nLow pass filter\nLow shelf\nUpper output limit\nOutput upper limit\nOutput upper limit\nLower output limit\nOutput lower limit\nOutput lower limit\nA notch filter\nFeedback term order\nFeedback term order\nA peaking/dip filter\nSample period\nA filter with the given proportional gain at all …\nSet Q parameter of the filter\nConvert input (<code>x</code>) offset to equivalent summing junction …\nSet the upper output limit\nSet the lower output limit\nSet the shape\nSet the summing junction offset\nSetpoint\nSet linear shelf gain\nSet shelf gain in dB\nSet the shelf slope.\nSumming junction offset\nSumming junction offset\nDirect Form 1 Update\nGain values\nSecond order state variable filter state\nState variable filter\nBandpass output\nBandreject (notch) output\nReturns the argument unchanged.\nReturns the argument unchanged.\nHighpass output\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLowpass output\nSet the critical frequency\nSet the Q parameter\nUpdate the filter")