<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Stabilizer DAC management interface"><title>stabilizer::hardware::dac - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="stabilizer" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-68b7e25d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../stabilizer/index.html">stabilizer</a><span class="version">0.11.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module dac</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#design" title="Design">Design</a><ul><li><a href="#multiple-samples-to-single-dac-codes" title="Multiple Samples to Single DAC Codes">Multiple Samples to Single DAC Codes</a></li></ul></li><li><a href="#note" title="Note">Note</a></li><li><a href="#limitations" title="Limitations">Limitations</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In stabilizer::<wbr>hardware</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">stabilizer</a>::<wbr><a href="../index.html">hardware</a></div><h1>Module <span>dac</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/stabilizer/hardware/dac.rs.html#1-221">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Stabilizer DAC management interface</p>
<h2 id="design"><a class="doc-anchor" href="#design">§</a>Design</h2>
<p>Stabilizer DACs are connected to the MCU via a simplex, SPI-compatible interface. Each DAC
accepts a 16-bit output code.</p>
<p>In order to maximize CPU processing time, the DAC code updates are offloaded to hardware using
a timer compare channel, DMA stream, and the DAC SPI interface.</p>
<p>The timer comparison channel is configured to generate a DMA request whenever the comparison
occurs. Thus, whenever a comparison happens, a single DAC code can be written to the output. By
configuring a DMA stream for a number of successive DAC codes, hardware can regularly update
the DAC without requiring the CPU.</p>
<p>In order to ensure alignment between the ADC sample batches and DAC output code batches, a DAC
output batch is always exactly 3 batches after the ADC batch that generated it.</p>
<p>The DMA transfer for the DAC output codes utilizes a double-buffer mode to avoid losing any
transfer events generated by the timer (for example, when 2 update cycles occur before the DMA
transfer completion is handled). In this mode, by the time DMA swaps buffers, there is always a valid buffer in the
“next-transfer” double-buffer location for the DMA transfer. Once a transfer completes,
software then has exactly one batch duration to fill the next buffer before its
transfer begins. If software does not meet this deadline, old data will be repeatedly generated
on the output and output will be shifted by one batch.</p>
<h3 id="multiple-samples-to-single-dac-codes"><a class="doc-anchor" href="#multiple-samples-to-single-dac-codes">§</a>Multiple Samples to Single DAC Codes</h3>
<p>For some applications, it may be desirable to generate a single DAC code from multiple ADC
samples. In order to maintain timing characteristics between ADC samples and DAC code outputs,
applications are required to generate one DAC code for each ADC sample. To accomodate mapping
multiple inputs to a single output, the output code can be repeated a number of times in the
output buffer corresponding with the number of input samples that were used to generate it.</p>
<h2 id="note"><a class="doc-anchor" href="#note">§</a>Note</h2>
<p>There is a very small amount of latency between updating the two DACs due to bus matrix
priority. As such, one of the DACs will be updated marginally earlier before the other because
the DMA requests are generated simultaneously. This can be avoided by providing a known offset
to other DMA requests, which can be completed by setting e.g. DAC0’s comparison to a
counter value of 2 and DAC1’s comparison to a counter value of 3. This will have the effect of
generating the DAC updates with a known latency of 1 timer tick to each other and prevent the
DMAs from racing for the bus. As implemented, the DMA channels utilize natural priority of the
DMA channels to arbitrate which transfer occurs first.</p>
<h2 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h2>
<p>While double-buffered mode is used for DMA to avoid lost DAC-update events, there is no check
for re-use of a previously provided DAC output buffer. It is assumed that the DMA request is
served promptly after the transfer completes.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Dac0Output.html" title="struct stabilizer::hardware::dac::Dac0Output">Dac0<wbr>Output</a></dt><dd>Represents data associated with DAC.</dd><dt><a class="struct" href="struct.Dac1Output.html" title="struct stabilizer::hardware::dac::Dac1Output">Dac1<wbr>Output</a></dt><dd>Represents data associated with DAC.</dd></dl></section></div></main></body></html>